					### https://medium.com/open-machine-learning-course/open-machine-learning-course-topic-2-visual-data-analysis-in-python-846b989675cd
					#   Оpen Machine Learning Course. 
					#   Topic 2. Visual Data Analysis with Python

# В этой статье мы собираемся получить практический опыт визуального исследования
# данных с использованием популярных библиотек, таких как pandas, matplotlib и seaborn.

							# 1) Dataset - Наборо данных

# Прежде чем мы перейдем к данным, давайте инициализируем нашу среду:
import numpy as np
import pandas as pd
pd.options.display.max_columns = 12

# Disable warnings in Anaconda
import warnings
warnings.simplefilter('ignore')

# We will display plots right inside Jupyter Notebook
# %matplotlib InlineBackend											???
#%matplotlib qt 

import matplotlib.pyplot as plt


# We will use the Seaborn library
import seaborn as sns
sns.set()

# Graphics in SVG format are more sharp and legible
# %config InlineBackend.figure_format = 'svg'						???

# Increase the default plot size
from pylab import rcParams
rcParams['figure.figsize'] = 5, 4 
df = pd.read_csv('../mlcourse.ai/data/telecom_churn.csv')
# print(df.head())

# Последний столбец данных, Churn, - наша целевая переменная. Он является двоичным: True указывает,
# что компания в конечном итоге потеряла этого клиента, а False указывает, что клиент был сохранен.

							# 2) Univariate visualization

# Одномерный анализ рассматривает одну переменную за раз. Когда мы анализируем функцию независимо,
# нас обычно больше всего интересует распределение ее значений и игнорируем другие переменные 
# в наборе данных. Ниже мы рассмотрим различные статистические типы переменных и соответствующие 
# инструменты для их индивидуального визуального анализа.

					# 2.1 Quantitative features - Количественные характеристики

# Количественные характеристики принимают упорядоченные числовые значения. 
# Эти значения могут быть дискретными, как целые числа, или непрерывными, 
# как действительные числа, и обычно выражают счет или измерение.

							# Histograms and density plots

# Самый простой способ взглянуть на распределение числовой переменной - 
# построить ее гистограмму с помощью метода hist () DataFrame.
# features = ['Total day minutes', 'Total intl calls']
# df[features].hist(figsize=(12, 4))
# Гистограмма группирует значения в интервалы равного диапазона значений.

# Есть также другой, часто более ясный способ понять распределение: 
# графики плотности или, более формально, графики плотности ядра. 
# Их можно считать сглаженной версией гистограммы. Их главное преимущество 
# перед последними в том, что они не зависят от размера бинов.

# Давайте создадим графики плотности для тех же двух переменных:
# df[features].plot(kind='density', subplots=True, layout=(1, 2), sharex=False, figsize=(12, 4))

# Также можно построить распределение наблюдений с помощью distplot () seaborn.
# Например, давайте посмотрим на распределение Всего минут дня. По умолчанию график 
# отображает обе гистограммы с оценкой плотности ядра (KDE) вверху.
# sns.distplot(df['Total intl calls'])
# Высота столбцов гистограммы здесь нормирована и показывает плотность, а не количество примеров в каждой ячейке.

								# Box plot

# Другой полезный тип визуализации - это ящичная диаграмма. Здесь seaborn отлично справляется:
# _, ax = plt.subplots(figsize=(3, 4))																							# ???
# sns.boxplot(data=df['Total intl calls'], ax=ax)
# Давайте посмотрим, как интерпретировать коробчатую диаграмму. Его составляющими 
# являются прямоугольник (очевидно, поэтому он называется коробчатым графиком), 
# так называемые усы и ряд отдельных точек (выбросов). Рамка сама по себе 
# иллюстрирует межквартильный разброс распределения; его длина 
# определяется 25-м (Q1) и 75-м (Q3) процентилями. Вертикальная линия 
# внутри рамки отмечает медианное значение (50%) распределения.
# Усы - это линии, идущие от коробки. Они представляют собой весь разброс точек данных,
# в частности, точки, которые попадают в интервал (Q1−1,5⋅IQR, Q3 + 1,5⋅IQR), 
# где IQR = Q3 − Q1 - межквартильный диапазон.
# Выбросы, выходящие за пределы диапазона, ограниченного усами, отображаются индивидуально 
# в виде черных точек вдоль центральной оси. Мы видим, что большое количество международных
# звонков в наших данных встречается довольно редко.

								# Violin plot

# Последний тип графиков распределения, который мы рассмотрим, - это скрипичный сюжет.
# Посмотрите на цифры ниже. Слева мы видим уже знакомый коробчатый сюжет. 
# Справа - скрипичный сюжет с оценкой плотности ядра по обеим сторонам.
# _, axes = plt.subplots(1, 2, sharey=True, figsize=(6, 4))
# sns.boxplot(data=df['Total intl calls'], ax=axes[0])
# sns.violinplot(data=df['Total intl calls'], ax=axes[1])
# Разница между графиками ящика и скрипки заключается в том, что первый иллюстрирует
# определенную статистику, касающуюся отдельных примеров в наборе данных, в то время 
# как график скрипки больше концентрируется на сглаженном распределении в целом.
# В нашем случае график скрипки не дает никакой дополнительной информации о данных,
# поскольку все ясно из одного только прямоугольного графика.

# В дополнение к графическим инструментам, чтобы получить точную числовую статистику 
# распределения, мы можем использовать метод describe () DataFrame: 
# print(df[features].describe())
# Его вывод в основном не требует пояснений. 25%, 50% и 75% - соответствующие процентили.

				# 2.2 Categorical and binary features - Категориальные и бинарные особенности

# Категориальные признаки принимают фиксированное количество значений. 
# Каждое из этих значений относит наблюдение к соответствующей группе, 
# известной как категория, которая отражает некоторые качественные свойства 
# этого примера. Двоичные переменные являются важным частным случаем 
# категориальных переменных, когда количество возможных значений равно 2.
# Если значения категориальной переменной упорядочены, это называется порядковым номером.

						# Frequency table - Таблица частот

# Давайте проверим баланс классов в нашем наборе данных, посмотрев на распределение
# целевой переменной: оттока. Сначала мы получим таблицу частот, которая показывает,
# насколько часто встречается каждое значение категориальной переменной.  
# Для этого воспользуемся методом value_counts ():
# print(df['Churn'].value_counts())
# По умолчанию записи в выводе отсортированы от наиболее часто встречающихся 
# к наименее часто встречающимся значениям.

# В нашем случае данные не сбалансированы; то есть два наших целевых класса, 
# лояльные и нелояльные клиенты, не представлены одинаково в наборе данных. 
# Лишь небольшая часть клиентов отказалась от подписки на услугу связи. 
# Как мы увидим в следующих статьях, этот факт может подразумевать некоторые 
# ограничения на измерение эффективности классификации, и в будущем мы, 
# возможно, захотим дополнительно наказать ошибки нашей модели при 
# прогнозировании класса «отток меньшинства».

							# Bar plot - гистограмма

# Bar plot (гистограмма) представляет собой графическое представление таблицы частот. 
# Самый простой способ создать его - использовать функцию countplot () для seaborn.
# В seaborn есть еще одна функция, которую несколько сбивает с толку barplot (), 
# которая в основном используется для представления некоторой базовой статистики 
# числовой переменной, сгруппированной по категориальному признаку.
# Построим распределения для двух категориальных переменных:

# _, axes = plt.subplots(nrows=1, ncols=2, figsize=(12, 4))
# sns.countplot(x='Churn', data=df, ax=axes[0])
# sns.countplot(x='Customer service calls', data=df, ax=axes[1])

# Хотя гистограммы, рассмотренные выше, и bar plot могут выглядеть одинаково, между ними есть несколько различий:
# 1) Гистограммы лучше всего подходят для просмотра распределения числовых переменных, 
# в то время как bar plot используются для категориальных функций.
# 2) Значения по оси X гистограммы являются числовыми; bar plot может иметь любой тип
# значений по оси X: числа, строки, логические значения.
# 3) Ось X гистограммы - это декартова ось координат, по которой значения не могут быть изменены;
# порядок bars заранее не определен. Тем не менее, полезно отметить, что bars часто 
# сортируются по высоте, то есть частоте значений. Кроме того, когда мы рассматриваем порядковые 
# переменные (например, обращения в службу поддержки клиентов в наших данных), bars обычно 
# упорядочиваются по значению переменной

# Левый график выше ярко иллюстрирует дисбаланс в нашей целевой переменной. Гистограмма для 
# обращений в службу поддержки справа указывает на то, что большинство клиентов решают свои 
# проблемы максимум за 2–3 звонка. Но поскольку мы хотим иметь возможность предсказать класс 
# меньшинства, нас может больше интересовать, как ведет себя меньшее количество недовольных 
# клиентов. Вполне может быть, что основная часть нашего оттока находится в хвосте этого 
# гистограммы. Пока это всего лишь гипотезы, поэтому давайте перейдем к более интересным и 
# мощным визуальным приемам.

					# 3) Multivariate visualization - Многомерная визуализация

# Многомерные графики позволяют нам видеть отношения между двумя и более разными переменными 
# на одном рисунке. Как и в случае одномерных графиков, конкретный тип визуализации будет 
# зависеть от типов анализируемых переменных.

				# 3.1 Quantitative–Quantitative - Количественный – количественный
# Мы начнем с взаимодействия количественных переменных.				
			
								# Correlation matrix

# Давайте посмотрим на корреляции между числовыми переменными в нашем наборе данных. 
# Эта информация важна, поскольку существуют алгоритмы машинного обучения (например, линейная 
# и логистическая регрессия), которые плохо обрабатывают сильно коррелированные входные переменные.
# Сначала мы будем использовать метод corr () в DataFrame, который вычисляет корреляцию 
# между каждой парой функций. Затем мы передаем полученную матрицу корреляции в heatmap () 
# из seaborn, которая отображает матрицу с цветовым кодированием для предоставленных значений:

# Drop non-numerical variables - Отбросить нечисловые переменные
# temp = ['State', 'International plan','Voice mail plan','Area code','Churn','Customer service calls']
# numerical = list(set(df.columns) - set(temp))
# Calculate and plot - Рассчитать и построить
# corr_matrix = df[numerical].corr()
# sns.heatmap(corr_matrix)

# Из цветной корреляционной матрицы, созданной выше, мы видим, что есть 4 переменных, 
# такие как общая дневная плата, которые были рассчитаны непосредственно из количества минут, 
# потраченных на телефонные звонки (общее количество минут за день). Они называются зависимыми
# переменными, и поэтому их можно не учитывать, поскольку они не вносят никакой дополнительной 
# информации. Избавимся от них:

# numerical = list(set(numerical) - set(['Total day charge','Total eve charge','Total night charge','Total intl charge']))
# corr_matrix = df[numerical].corr()
# sns.heatmap(corr_matrix)

							# Scatter plot - Диаграмма разброса (рассеяния)

# Диаграмма рассеяния отображает значения двух числовых переменных в виде декартовых координат
# в 2D-пространстве. Также возможны точечные графики в 3D.
# Давайте попробуем функцию scatter () из библиотеки matplotlib:							
# plt.scatter(df['Total day minutes'], df['Total night minutes']);
# Мы получаем неинтересную картину двух нормально распределенных переменных. Кроме того,
# кажется, что эти особенности не коррелированы, потому что эллиптическая форма выровнена с осями.

# Есть более интересный вариант для создания диаграммы рассеяния с помощью библиотеки seaborn:
# sns.jointplot(x = 'Total day minutes', y = 'Total night minutes', data = df, kind = 'scatter');
# Функция Jointplot () строит две гистограммы, которые могут быть полезны в некоторых случаях. 
# Используя ту же функцию, мы также можем получить сглаженную версию нашего двумерного распределения:
# sns.jointplot('Total day minutes', 'Total night minutes', data = df, kind = "kde", color = "g");
# По сути, это двумерная версия графика плотности ядра, обсуждавшаяся ранее.

							# Scatterplot matrix - Матрица диаграммы рассеяния

# В некоторых случаях нам может потребоваться построить матрицу точечной диаграммы, например, 
# показанную ниже. Его диагональ содержит распределения соответствующих переменных, а диаграммы 
# разброса для каждой пары переменных заполняют остальную часть матрицы							
# pairplot may become very slow with the SVG format (pairplot может работать очень медленно с форматом SVG)
# %config InlineBackend.figure_format = 'png'										???

# temp = ['State', 'International plan','Voice mail plan','Area code','Churn','Customer service calls']
# numerical = list(set(df.columns) - set(temp))
# InlineBackend.figure_format = 'png' 
# sns.pairplot(df[numerical])
# Иногда такая визуализация может помочь сделать выводы о данных; но в этом случае все предельно ясно и без сюрпризов.


						# 3.2 Quantitative–Categorical - Количественно-категориальный

# В этом разделе мы сделаем наши простые количественные графики немного более увлекательными. 
# Мы постараемся получить новое представление о прогнозировании оттока клиентов на основе 
# взаимодействия между числовыми и категориальными характеристиками.

# В частности, давайте посмотрим, как входные переменные связаны с целевой переменной Churn.

# Ранее вы узнали о диаграммах рассеяния. Кроме того, их точки могут иметь кодировку цвета или размера, 
# так что значения третьей категориальной переменной также представлены на том же рисунке. Мы можем 
# добиться этого с помощью функции scatter (), показанной выше, но давайте попробуем новую функцию под 
# названием lmplot () и воспользуемся параметром hue для обозначения интересующей нас категориальной особенности:

# sns.lmplot('Total day minutes', 'Total night minutes', data = df, hue = 'Churn', fit_reg = False);

# Теперь давайте создадим коробчатые диаграммы для визуализации статистики распределения числовых переменных 
# в двух непересекающихся группах: постоянных клиентов (отток = ложь) и тех, кто ушел (отток = истина).

# Иногда можно анализировать порядковую переменную как числовую 
# temp = ['State', 'International plan','Voice mail plan','Area code','Churn','Customer service calls']
# numerical = list(set(df.columns) - set(temp))
# numerical.append('Customer service calls') 

## fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(10, 7))					??? Error in code
# fig, axes = plt.subplots(nrows=4, ncols=4, figsize=(10, 7))
# for idx, feat in enumerate(numerical): 
#     ax = axes[int(idx / 4), idx % 4] 
#     sns.boxplot(x='Churn', y=feat, data=df, ax=ax) 
#     ax.set_xlabel('') 
#     ax.set_ylabel(feat) 
# fig.tight_layout();

# Из этой диаграммы мы видим, что наибольшее расхождение в распределении между двумя группами связано с тремя 
# переменными: Total day minutes, Customer service calls, and Number vmail messages  - 
# общее количество минут в день, звонки в службу поддержки и количество сообщений vmail. 
# Позже в этом курсе мы узнаем, как определять важность функции в классификации с помощью случайного леса или 
# повышения градиента; там мы увидим, что первые две функции действительно очень важны для прогнозирования оттока.

# Давайте посмотрим на распределение дневных минут для лояльных и нелояльных клиентов по отдельности. Мы создадим
# графики box и violin для общего количества минут дня, сгруппированных по целевой переменной.
# _, axes = plt.subplots(1, 2, sharey = True, figsize = (10, 4)) 
# sns.boxplot(x = 'Churn', y = 'Total day minutes', data = df, ax = axes[0]);
# sns.violinplot(x = 'Churn', y = 'Total day minutes', data = df, ax = axes[1]);
# В этом случае violin не дает никакой дополнительной информации о наших данных, поскольку все ясно
# из одного лишь графического представления: нелояльные клиенты, как правило, больше разговаривают по телефону.
# Интересное наблюдение: в среднем клиенты, расторгающие контракты, более активно пользуются услугами связи. Возможно, 
# они недовольны тарифами, поэтому возможной мерой предотвращения оттока может стать снижение тарифов на звонки. 
# Компании потребуется провести дополнительный экономический анализ, чтобы выяснить, принесут ли такие меры пользу.

# Когда мы хотим проанализировать количественную переменную сразу в двух категориальных измерениях, для этого есть
# подходящая функция в библиотеке seaborn, которая называется factorplot (). Например, давайте визуализируем взаимодействие 
# между общими дневными минутами и двумя категориальными переменными на одном графике:

# sns.factorplot(x = 'Churn', y = 'Total day minutes', col = 'Customer service calls', data = df[df['Customer service calls'] < 8], 
#                kind="box", col_wrap=4, size=3, aspect=.8);
# Из этого можно сделать вывод, что, начиная с 4 звонков, общее количество минут в день больше не может быть основным 
# фактором оттока клиентов. Возможно, помимо нашего предыдущего предположения о тарифах, есть клиенты, которые недовольны 
# услугой из-за других проблем, что может привести к меньшему количеству дневных минут, потраченных на звонки.

						# 3.3 Categorical–Categorical - Категориально-категориальный

# Как мы видели ранее в этой статье, переменная «Звонки в службу поддержки клиентов» имеет несколько 
# уникальных значений и, таким образом, может считаться числовой или порядковой. Мы уже видели его 
# распределение со счетным графиком. Теперь нас интересует связь между этим порядковым номером и 
# целевой переменной Churn.

# Давайте посмотрим на распределение количества звонков в службу поддержки клиентов, снова используя 
# график подсчета. На этот раз давайте также передадим параметр hue = Churn, который добавляет 
# категориальное измерение к графику:
# sns.countplot(x = 'Customer service calls', hue = 'Churn', data = df);
# Наблюдение: уровень оттока значительно увеличивается после 4 и более обращений в службу поддержки.

# Теперь давайте посмотрим на взаимосвязь между оттоком и бинарными функциями, международным планом и 
# тарифным планом голосовой почты.
# _, axes = plt.subplots(1, 2, sharey = True, figsize = (10, 4)) 
# sns.countplot(x = 'International plan', hue = 'Churn', data = df, ax = axes[0]);
# sns.countplot(x = 'Voice mail plan', hue = 'Churn', data = df, ax = axes[1]);
# Наблюдение: когда включен международный план, процент оттока намного выше; использование международного 
# плана заказчиком является сильной стороной. Мы не наблюдаем такого же эффекта с тарифным планом голосовой почты.

			# Contingency table - Таблица сопряженности (непредвиденных обстоятельств, кросс-таблицей)

# Помимо использования графических средств для категориального анализа, существует традиционный инструмент
# статистики: таблица непредвиденных обстоятельств, также называемая кросс-таблицей. Он представляет многомерное
# частотное распределение категориальных переменных в табличной форме. В частности, это позволяет нам увидеть
# распределение одной переменной, обусловленной другой, по столбцу или строке.

# Давайте попробуем увидеть, как отток связан с категориальной переменной State, создав кросс-таблицу:
# print(pd.crosstab(df['State'], df['Churn']).T)
# В случае состояния число различных значений довольно велико: 51. Мы видим, что для каждого отдельного
# состояния доступно только несколько точек данных - только от 3 до 17 клиентов в каждом штате отказались 
# от оператора. Давайте проигнорируем это на секунду и вычислим коэффициент оттока для каждого состояния, 
# отсортировав его от большего к меньшему:
# print(df.groupby(['State'])['Churn'].agg([np.mean]).sort_values(by='mean', ascending=False).T)
# На первый взгляд кажется, что уровень оттока в Нью-Джерси и Калифорнии превышает 25% и меньше 6% 
# на Гавайях и Аляске. Однако эти выводы основаны на слишком небольшом количестве примеров, и наши наблюдения 
# могут быть просто свойством нашего конкретного набора данных. Мы можем подтвердить это с помощью гипотез 
# корреляции Мэтьюза и Крамера, но это выходит за рамки данной статьи.													???

					# 4. Whole dataset - Весь набор данных

				# 4.1 Naive approach - Наивный подход

# Мы изучали различные аспекты нашего набора данных, угадывая интересные особенности и выбирая небольшое 
# количество из них для визуализации. У нас есть только дельта с двумя-тремя переменными одновременно, 
# и мы легко можем наблюдать структуру и отношения в данных. Но что, если мы хотим отобразить все 
# функции и по-прежнему иметь возможность интерпретировать полученную визуализацию?

# Мы могли бы использовать hist () или создать матрицу диаграммы рассеяния с помощью pairplot () 
# для всего набора данных, чтобы просматривать все наши функции одновременно. Но когда количество 
# функций достаточно велико, этот вид визуального анализа быстро становится медленным и неэффективным. 
# Кроме того, мы по-прежнему будем анализировать наши переменные попарно, а не все сразу.

				# 4.2 Dimensionality reduction - Снижение размерности

# Большинство реальных наборов данных имеют множество функций, иногда даже многие тысячи. Каждый из них 
# можно рассматривать как измерение в пространстве точек данных. Следовательно, чаще всего мы имеем дело 
# с многомерными наборами данных, где полная визуализация довольно сложна.

# Чтобы посмотреть на набор данных в целом, нам нужно уменьшить количество измерений, используемых в визуализации, 
# без потери большой информации о данных. Эта задача называется уменьшением размерности и является примером 
# проблемы неконтролируемого обучения, потому что нам нужно вывести новые низкоразмерные функции из самих 
# данных без какого-либо контролируемого ввода.

# Одним из хорошо известных методов уменьшения размерности является анализ главных компонентов (Principal 
# Component Analysis - PCA), который мы изучим позже в этом курсе. Его ограничение заключается в том, что 
# это линейный алгоритм, который подразумевает определенные ограничения на данные.

# Существует также множество нелинейных методов, которые вместе называются Manifold Learning. 
# (Множественное обучение). Один из самых известных из них - t-SNE.

									# 4.3 t-SNE

# Давайте создадим представление t-SNE тех же данных об оттоке, которые мы использовали.
# Название метода выглядит сложным и немного пугающим: t-distributed Stohastic Neighbor Embedding 
# (t-распределенное стохастическое соседнее встраивание).

# Его математика также впечатляет (мы не будем углубляться в это здесь, но, если вы чувствуете себя смелым, 
# вот оригинальная статья Лоренса ван дер Маатена и Джеффри Хинтона из JMLR). Его основная идея проста: 
# найти проекцию многомерного пространства признаков на плоскость (или трехмерную гиперплоскость, но она 
# почти всегда двумерная), чтобы те точки, которые находились далеко друг от друга в исходном n-мерном 
# пространстве, окажутся далеко друг от друга на плоскости. Те, что были изначально близки, останутся близкими друг к другу.

# По сути, встраивание соседей - это поиск нового и менее размерного представления данных, которое сохраняет соседство примеров.
# А теперь давайте попрактикуемся. Во-первых, нам нужно импортировать некоторыsе дополнительные классы:

from sklearn.manifold import TSNE
from sklearn.preprocessing import StandardScaler

# Мы оставим функции State и Churn и преобразуем значения «Да» / «Нет» двоичных функций в числовые значения с помощью pandas.Series.map():
X = df.drop(['Churn', 'State'], axis = 1)
X['International plan'] = X['International plan'].map({'Yes': 1, 'No': 0})
X['Voice mail plan'] = X['Voice mail plan'].map({'Yes': 1, 'No': 0})
# Нам также необходимо нормализовать данные. Для этого мы вычтем среднее значение каждой переменной и 
# разделим его на стандартное отклонение. Все это можно сделать с помощью StandardScaler.
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
# Теперь давайте построим представление t-SNE: 
# %%time tsne = TSNE(random_state=17)													???
tsne = TSNE(random_state = 17)
tsne_repr = tsne.fit_transform(X_scaled)
# и нарисуем это:
# plt.scatter(tsne_repr[:, 0], tsne_repr[:, 1]);
# Давайте раскрасим это представление t-SNE в соответствии с оттоком (зеленый для постоянных клиентов и красный для тех, кто ушел).
# plt.scatter(tsne_repr[:, 0], tsne_repr[:, 1], c = df['Churn'].map({False: 'green', True: 'red'}));
# Мы видим, что отток клиентов сконцентрирован в нескольких областях функционального пространства более низкой размерности.

# Чтобы лучше понять картину, мы также можем раскрасить ее оставшимися двоичными функциями: международный план и голосовая
# почта. Зеленые точки здесь указывают на объекты, которые являются положительными для соответствующей двоичной функции.
_, axes = plt.subplots(1, 2, sharey = True, figsize = (12, 5))
for i, name in enumerate(['International plan', 'Voice mail plan']):
    axes[i].scatter(tsne_repr[:, 0], tsne_repr[:, 1], c = df[name].map({'Yes': 'green', 'No': 'red'}))
    axes[i].set_title(name)
# Теперь ясно, что, например, многие недовольные клиенты, которые отменили свою подписку, 
# скапливаются в самом юго-западном кластере, который представляет людей с международным тарифным планом, 
# но без голосовой почты.

# Наконец, отметим некоторые недостатки t-SNE:
# 1) Высокая вычислительная сложность. Реализация в scikit-learn вряд ли осуществима в реальной задаче. 
# Если у вас большое количество образцов, вам следует попробовать Multicore-TSNE.
# 2) Сюжет может сильно измениться в зависимости от случайного начального числа, что усложняет интерпретацию. 
# Вот хороший учебник по t-SNE. В общем, не следует делать каких-либо далеко идущих выводов на основе таких 
# графиков, потому что это можно приравнять к простому предположению. Конечно, некоторые находки на изображениях 
# t-SNE могут вдохновить на идею и быть подтверждены более тщательными исследованиями в будущем, но это случается 
# не очень часто.
# 3) Иногда, используя t-SNE, вы можете получить действительно хорошую интуицию в отношении данных. Следующая 
# хорошая статья показывает пример этого для рукописных цифр: Визуализация MNIST.

# Иногда t-SNE действительно помогает что-то понять, а иногда можно просто нарисовать елочную игрушку :-)

plt.show()






