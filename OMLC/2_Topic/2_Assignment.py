# https://www.kaggle.com/kashnitsky/a2-demo-analyzing-cardiovascular-data?scriptVersionId=37925604
										# Домашнее задание № 2 (демо).
								# Анализ данных о сердечно-сосудистых заболеваниях

# В этом задании вы ответите на вопросы о наборе данных о сердечно-сосудистых заболеваниях.
# Проблема: Прогнозируйте наличие или отсутствие сердечно-сосудистых заболеваний (ССЗ) по результатам обследования пациента.

# Описание данных
# Есть 3 типа входных функций:
# 1) Objective: factual information - Цель: фактическая информация;
# 2) Examination: results of medical examination - Обследование: результаты медицинского обследования
# 3) Subjective: information given by the patient - Субъективно: информация, предоставленная пациентом.

# Давайте познакомимся с нашими данными, выполнив предварительный анализ данных.
# Сначала мы инициализируем среду:

# Import all required modules
import pandas as pd
import numpy as np

# Disable warnings
import warnings
warnings.filterwarnings("ignore")

# Import plotting modules
import seaborn as sns
sns.set()
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.ticker

# Вы будете использовать библиотеку seaborn для визуального анализа, 
# так что давайте настроим и ее:
sns.set_context(
    "notebook", 
    font_scale=1.5,       
    rc={ 
        "figure.figsize": (11, 8), 
        "axes.titlesize": 18 
    }
)

from matplotlib import rcParams
rcParams['figure.figsize'] = 11, 8

# Для простоты будем работать только с обучающей частью набора данных:

df = pd.read_csv('../mlcourse.ai/data/mlbootcamp5_train.csv', sep = ';')
print('Dataset size: ', df.shape)

# pd.set_option('display.max_columns', 100)
# pd.set_option('display.max_rows', 100)

print(df.head())
# print(df.columns)

# Было бы поучительно взглянуть на значения наших переменных.

# Давайте преобразуем данные в длинный формат и изобразим количество 
# значений категориальных функций с помощью factorplot ().

# df_uniques = pd.melt(frame=df, value_vars=['gender','cholesterol','gluc', 'smoke', 'alco','active', 'cardio'])
# df_uniques = pd.DataFrame(df_uniques.groupby(['variable', 
# 			'value'])['value'].count()).sort_index(level=[0, 1]) \
#     		.rename(columns={'value': 'count'}).reset_index()

# sns.factorplot(x='variable', y='count', hue='value', data=df_uniques, kind='bar', size = 7, aspect = 1.5);
# Мы видим, что целевые классы сбалансированы. Замечательно!

# Разобьем набор данных по целевым значениям. Можете ли вы определить наиболее значительную особенность, 
# просто взглянув на сюжет?

# df_uniques = pd.melt(frame=df, value_vars=['gender','cholesterol','gluc', 'smoke', 'alco','active'],id_vars=['cardio'])

# df_uniques = pd.DataFrame(df_uniques.groupby(['variable', 'value', 
#                                               'cardio'])['value'].count()) \
#     .sort_index(level=[0, 1]) \
#     .rename(columns={'value': 'count'}) \
#     .reset_index()

# sns.factorplot(x='variable', y='count', hue='value', col='cardio', data=df_uniques, kind='bar', size = 7, aspect = 1.5);

# Вы можете видеть, что распределение уровней холестерина и глюкозы сильно различается по значению 
# целевой переменной. Это совпадение?

# Теперь давайте посчитаем некоторую статистику для уникальных значений функции:

for c in df.columns:
    n = df[c].nunique()
    print(c)
    if n <= 3:
        print(n, sorted(df[c].value_counts().to_dict().items()))
    else:
        print(n)
    print(10 * '-')

# В итоге имеем:

# 5 числовых характеристик (без идентификатора);
# 7 категориальных признаков;
# Всего 70000 записей.



"""

                                                                # Основные наблюдения

# Вопрос 1.1. (1 балл). Сколько мужчин и женщин присутствует в этом наборе данных? 
# Значения гендерного признака не приводились (независимо от того, обозначает ли «1» 
# женщин или мужчин) - выясните это, проанализировав рост, исходя из предположения, 
# что мужчины в среднем выше.

h_1 = df[df['gender'] == 1]['height'].mean()
h_2 = df[df['gender'] == 2]['height'].mean() 
d = { 1 if h_1 < h_2 else 2 : 'Female' , 2 if h_1 < h_2 else 1 : 'Male'}
df['gender'] = df['gender'].map(d)
sns.factorplot(x = 'gender', y = 'height', data = df, kind="violin", size = 6, aspect = 1.5);
print('1.1 Сколько мужчин и женщин присутствует в этом наборе данных?')
print(df['gender'].value_counts())

# Вопрос 1.2. (1 балл). Какой пол чаще сообщает о потреблении алкоголя - мужчины или женщины?
_, axes = plt.subplots(nrows=1, ncols=2, figsize=(10, 7))
print('1.2 Какой пол чаще сообщает о потреблении алкоголя - мужчины или женщины?')
sns.countplot(x='gender', hue='alco', data = df, ax = axes[0]);
alco_F = df[df['gender'] == 'Female']['alco'].value_counts(normalize = True)[1]
alco_M = df[df['gender'] == 'Male']['alco'].value_counts(normalize = True)[1]
print('Female' if alco_F > alco_M else 'Male')

# Вопрос 1.3. (1 балл). Какая разница между процентами курильщиков среди мужчин и женщин (округлено)?
print('1.3 Какая разница между процентами курильщиков среди мужчин и женщин (округлено)?')
sns.countplot(x='gender', hue='smoke', data = df, ax = axes[1]);
smoke_F = df[df['gender'] == 'Female']['smoke'].value_counts(normalize = True)[1]
smoke_M = df[df['gender'] == 'Male']['smoke'].value_counts(normalize = True)[1]
print(round((smoke_M - smoke_F)*100))
# print((smoke_M - smoke_F))

# Вопрос 1.4. (1 балл). В чем разница между медианными значениями возраста для курильщиков и некурящих 
# (в месяцах, округлено)? Вам нужно будет определить единицы возраста объекта в этом наборе данных.
print('1.4 В чем разница между медианными значениями возраста для курильщиков и некурящих')
print('(в месяцах, округлено)? Вам нужно будет определить единицы возраста объекта в этом наборе данных.')

plt.subplots(1, 1, sharey = True, figsize = (10, 7)) 
sns.violinplot(x = 'smoke', y = 'age', data = df);

age_sm = df[df['smoke'] == 1]['age'].median()
age_no = df[df['smoke'] == 0]['age'].median()
print(round((age_no-age_sm)/30))

# На веб-сайте Европейского общества кардиологов представлена шкала SCORE. Он используется для 
# расчета риска смерти от сердечно-сосудистого заболевания в ближайшие 10 лет. Вот:

# Давайте посмотрим на верхний правый прямоугольник, который показывает подгруппу курящих 
# мужчин в возрасте от 60 до 65 лет (это не очевидно, но значения на рисунке представляют 
# собой верхнюю границу).

# Мы видим значение 9 в нижнем левом углу прямоугольника и 47 в правом верхнем углу. 
# Это означает, что для людей этой половой возрастной группы, у которых систолическое 
# давление ниже 120, риск сердечно-сосудистых заболеваний оценивается в 5 раз ниже, 
# чем для людей с давлением в интервале [160, 180).

# Давайте рассчитаем это же соотношение, используя наши данные.

# Вычислить признак age_years - округлить возраст до ближайшего числа лет. 
# Для этого задания отбираются только люди в возрасте от 60 до 64 лет включительно.
df['age_years'] = round(df['age']/365)
# print(df.head())

# Категории уровня холестерина различаются между цифрой и нашим набором данных. 
# Преобразование для характеристики холестерина выглядит следующим образом:
# 4 mmol/l -> 1, 5-7 mmol/l -> 2, 8 mmol/l -> 3.

# plt.subplots(1, 1, sharey = True, figsize = (10, 7)) 
# sns.violinplot(x = df['cholesterol']);

print('1.5 Подсчитайте долю людей с сердечно-сосудистыми заболеваниями для двух')
print('описанных выше сегментов. Каково соотношение этих двух фракций?')
sns.factorplot(x = 'cholesterol', y = 'cardio', col = 'age_years', data=df[(df['age_years'] >= 60) & (df['age_years'] <= 64)], size = 4, aspect = 0.8);

                # BMI

# Создайте новую функцию - BMI (индекс массы тела). Для этого вес в килограммах 
# разделите на квадрат роста в метрах. Нормальные значения ИМТ составляют от 18,5 до 25.
df['bmi'] = df['weight'] /  ((df['height']/100) ** 2)
# print(df.head())

print("1.6. (2 балла). Выберите правильные утверждения:")

print("Медиана ИМТ в выборке находится в диапазоне нормальных значений ИМТ (от 18,5 до 25).")
print(df['bmi'].median())
print("ИМТ у женщин в среднем выше, чем у мужчин.")
print('женщины: ' + str(df[df['gender'] == 'Female']['bmi'].mean()))
print('мужчины: ' +  str(df[df['gender'] == 'Male']['bmi'].mean()))
print("У здоровых людей в среднем более высокий ИМТ, чем у людей с сердечно-сосудистыми заболеваниями.")
print('здоровые: ' + str(df[df['cardio'] == 0]['bmi'].mean()))
print('больные:  ' + str(df[df['cardio'] == 1]['bmi'].mean()))
print("Для здоровых, не пьющих мужчин ИМТ ближе к норме, чем для здоровых, не пьющих женщин.")
print('мужчины: ' + str(df[(df['cardio'] == 0) & (df['gender'] == 'Male') & (df['alco'] == 0)]['bmi'].mean()))
print('женщины: ' + str(df[(df['cardio'] == 0) & (df['gender'] == 'Female') & (df['alco'] == 0)]['bmi'].mean()))



"""



# Мы видим, что данные не идеальны. Он содержит «грязь» и неточности. Мы увидим это лучше, когда визуализируем данные.
# Отфильтровать следующие сегменты пациентов (мы считаем это ошибочными данными)

# диастолическое давление выше систолического
# рост строго меньше 2,5 процентиля (используйте pd.Series.quantile для вычисления этого значения. Если вы не знакомы с функцией, прочтите документацию.)
min_height = df['height'].quantile(0.025)
# рост строго больше 97,5 процентиля
max_height = df['height'].quantile(0.975)
# вес строго меньше 2,5 процентиля
min_weight = df['weight'].quantile(0.025)
# вес строго больше 97,5 процентиля
max_weight = df['weight'].quantile(0.975)


temp = df[(df['ap_lo'] <= df['ap_hi']) & (df['height'] >= min_height) & (df['height'] <= max_height) & (df['weight'] >= min_weight) & (df['weight'] <= max_weight)]
print('1.7 Какой процент исходных данных (с округлением) мы выбросили?')
print(round((1 - temp.shape[0]/df.shape[0])*100))


                                            # Part 2. Visual data analysis

# 2.1. Визуализация корреляционной матрицы
# Чтобы лучше понять функции, вы можете создать матрицу коэффициентов корреляции 
# между функциями. Используйте исходный набор данных (без фильтрации).



# Постройте корреляционную матрицу, используя heatmap(). Вы можете создать матрицу 
# с помощью стандартных инструментов pandas с параметрами по умолчанию.


print('2.1 Какая пара признаков имеет наиболее сильную корреляцию Пирсона с гендерным признаком?')

numerical = list(set(df.columns))
corr_matrix = df[numerical].corr()
print(corr_matrix)
sns.heatmap(corr_matrix)
print('Height, Smoke')

# 2.2. Распределение роста мужчин и женщин
# Из нашего исследования уникальных значений ранее мы знаем, что пол кодируется значениями 1 и 2. 
# Хотя вы не знаете, как эти значения соотносятся с полом, вы можете вычислить это графически,
# посмотрев на средние значения роста. и вес для каждого значения гендерного признака.


# Создайте график скрипки для роста и пола с помощью скрипки (). Используйте параметры:
# оттенок разделить по полу;
# шкала для оценки количества записей для каждого пола.
# Чтобы график отображался правильно, вам необходимо преобразовать DataFrame в длинный формат с 
# помощью функции melt () из pandas. Вот пример для вашей справки.


plt.subplots(1, 1, sharey = True, figsize = (10, 7)) 
sns.violinplot(x='variable', y='value', hue='gender', data=pd.melt(df, value_vars = 'height', id_vars = 'gender'))


# 2.3. Корреляция рангов
# В большинстве случаев коэффициента линейной корреляции Пирсона более чем достаточно для обнаружения 
# закономерностей в данных. Но давайте пойдем немного дальше и вычислим ранговую корреляцию. Это 
# поможет нам идентифицировать такие пары признаков, в которых более низкий ранг в вариационном 
# ряду одного признака всегда предшествует более высокому рангу в другом (и у нас наоборот в 
# случае отрицательной корреляции).

# Рассчитайте и постройте корреляционную матрицу, используя коэффициент ранговой корреляции Спирмена.
# numerical = list(set(df.columns) - )
corr_matrix_spearman = df.corr(method = 'spearman')
print(corr_matrix_spearman)
plt.subplots(1, 1, sharey = True, figsize = (10, 7)) 
sns.heatmap(corr_matrix_spearman)

print('2.2 Какая пара характеристик имеет самую сильную корреляцию Спирмена?')
print('Ap_hi, Ap_lo')

print('2.3 Почему у этих функций сильная ранговая корреляция?') #???
# Неточности в данных (ошибки сбора данных).
# Связь неправильная, эти функции не должны быть связаны.
# Характер данных.


# Ранее мы рассчитывали возраст респондентов в годах на момент обследования.
# Создайте график подсчета с помощью countplot () с возрастом по оси X и количеством людей по оси Y. 
# На полученном графике должно быть по две колонки для каждого возраста, что соответствует 
# количеству людей для каждого кардио-класса этого возраста

df['age_years'] = round(df['age']/365)

plt.subplots(1, 1, sharey = True, figsize = (14, 8)) 
sns.countplot(x = 'age_years', hue='cardio', data = df);

print('2.4 В каком минимальном возрасте число людей с сердечно-сосудистыми заболеваниями')
print('превышает число людей без сердечно-сосудистых заболеваний?')
print('55')




plt.show()














